import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';

/// Builder function for the BindX generator
Builder bindxGenerator(BuilderOptions options) =>
    LibraryBuilder(BindxGenerator(), generatedExtension: '.bindx.dart');

/// Generator that creates BindX extensions for classes with annotated members
class BindxGenerator extends Generator {
  @override
  Future<String?> generate(LibraryReader library, BuildStep buildStep) async {
    final buffer = StringBuffer();
    bool headerWritten = false;

    // Check all classes in the library
    for (final element in library.allElements) {
      if (element is ClassElement) {
        // Check if the class has any annotated members
        if (_hasAnnotatedMembers(element)) {
          if (!headerWritten) {
            final fileName = buildStep.inputId.pathSegments.last;
            buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
            buffer.writeln('// Generated by BindxGenerator');
            buffer.writeln();
            buffer.writeln("part of '$fileName';");
            buffer.writeln();
            headerWritten = true;
          }
          buffer.writeln(_generateStoreClass(element));
          buffer.writeln();
        }
      }
    }

    return headerWritten ? buffer.toString() : null;
  }

  bool _hasAnnotatedMembers(ClassElement element) {
    // Check for Cache annotations
    final cacheChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/cache_annotation.dart#Cache',
    );

    // Check for Concurrent annotations
    final concurrentChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Concurrent',
    );

    // Check for Streamed annotations
    final streamedChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/stream_annotation.dart#Streamed',
    );

    // Check for Validate annotations
    final validateChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/validator_annotation.dart#Validate',
    );

    // Check for Retry annotations
    final retryChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Retry',
    );

    // Check for Mutex annotations
    final mutexChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Mutex',
    );

    // Check for Timeout annotations
    final timeoutChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Timeout',
    );

    // Check fields
    for (final field in element.fields) {
      if (cacheChecker.hasAnnotationOf(field) ||
          streamedChecker.hasAnnotationOf(field) ||
          validateChecker.hasAnnotationOf(field)) {
        return true;
      }
    }

    // Check methods
    for (final method in element.methods) {
      if (cacheChecker.hasAnnotationOf(method) ||
          concurrentChecker.hasAnnotationOf(method) ||
          retryChecker.hasAnnotationOf(method) ||
          mutexChecker.hasAnnotationOf(method) ||
          timeoutChecker.hasAnnotationOf(method)) {
        return true;
      }
    }

    return false;
  }

  String _generateStoreClass(ClassElement element) {
    final className = element.name;
    final buffer = StringBuffer();

    // Generate extension header
    buffer.writeln('extension ${className}Bindx on $className {');

    // Generate cached getters for fields
    buffer.write(_generateCachedGetters(element));

    // Generate concurrent method wrappers
    buffer.write(_generateConcurrentMethods(element));

    // Generate streamed properties
    buffer.write(_generateStreamedProperties(element));

    // Generate validated setters
    buffer.write(_generateValidatedSetters(element));

    // Generate retry wrappers
    buffer.write(_generateRetryMethods(element));

    // Generate mutex-protected methods
    buffer.write(_generateMutexMethods(element));

    // Generate timeout wrappers
    buffer.write(_generateTimeoutMethods(element));

    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateCachedGetters(ClassElement element) {
    final buffer = StringBuffer();
    final cacheChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/cache_annotation.dart#Cache',
    );

    for (final field in element.fields) {
      if (field.isStatic || field.isConst) continue;

      final cacheAnnotation = _getAnnotation(field, cacheChecker);
      if (cacheAnnotation != null) {
        final fieldName = field.name;
        final type = field.type.getDisplayString();
        final key = cacheAnnotation.peek('key')?.stringValue ?? fieldName;

        buffer.writeln('  /// Cached getter for $fieldName');
        buffer.writeln('  $type get ${fieldName}Cached {');
        buffer.writeln(
          '    return getCached(\'$key\', () => this.$fieldName);',
        );
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateConcurrentMethods(ClassElement element) {
    final buffer = StringBuffer();
    final concurrentChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Concurrent',
    );

    for (final method in element.methods) {
      if (method.isStatic) continue;

      final concurrentAnnotation = _getAnnotation(method, concurrentChecker);
      if (concurrentAnnotation != null) {
        final methodName = method.name;
        final returnType = method.returnType.getDisplayString();
        final params = _generateMethodParams(method);
        final paramNames = _generateParamNames(method);
        final annotationParams = _generateConcurrentAnnotationParams(
          concurrentAnnotation,
        );

        buffer.writeln('  /// Concurrent wrapper for $methodName');
        buffer.writeln(
          '  $returnType ${methodName}Concurrent($params) async {',
        );
        buffer.writeln('    return await executeConcurrent(');
        buffer.writeln('      () => this.$methodName($paramNames),');
        buffer.writeln('      annotation: _${methodName}ConcurrentConfig,');
        buffer.writeln('    );');
        buffer.writeln('  }');
        buffer.writeln();
        buffer.writeln(
          '  static const _${methodName}ConcurrentConfig = Concurrent(',
        );
        buffer.writeln('    $annotationParams');
        buffer.writeln('  );');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateStreamedProperties(ClassElement element) {
    final buffer = StringBuffer();
    final streamedChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/stream_annotation.dart#Streamed',
    );

    for (final field in element.fields) {
      if (field.isStatic || field.isConst) continue;

      final streamedAnnotation = _getAnnotation(field, streamedChecker);
      if (streamedAnnotation != null) {
        final fieldName = field.name;
        final type = field.type.getDisplayString();
        final streamKey =
            streamedAnnotation.peek('streamKey')?.stringValue ?? fieldName;

        buffer.writeln('  /// Stream for $fieldName');
        buffer.writeln('  Stream<$type> get ${fieldName}Stream {');
        buffer.writeln('    return streamOf<$type>(\'$streamKey\');');
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateValidatedSetters(ClassElement element) {
    final buffer = StringBuffer();
    final validateChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/validator_annotation.dart#Validate',
    );

    for (final field in element.fields) {
      if (field.isStatic || field.isConst || field.isFinal) continue;

      final validateAnnotation = _getAnnotation(field, validateChecker);
      if (validateAnnotation != null) {
        final fieldName = field.name;
        final type = field.type.getDisplayString();
        final validatorsCode = _generateValidators(validateAnnotation);

        buffer.writeln('  /// Validated setter for $fieldName');
        buffer.writeln(
          '  void set${_capitalize(fieldName ?? '')}Validated($type value) {',
        );
        if (validatorsCode.isNotEmpty) {
          buffer.write(validatorsCode);
        }
        buffer.writeln('    this.$fieldName = value;');
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateRetryMethods(ClassElement element) {
    final buffer = StringBuffer();
    final retryChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Retry',
    );

    for (final method in element.methods) {
      if (method.isStatic) continue;

      final retryAnnotation = _getAnnotation(method, retryChecker);
      if (retryAnnotation != null) {
        final methodName = method.name;
        final returnType = method.returnType.getDisplayString();
        final params = _generateMethodParams(method);
        final paramNames = _generateParamNames(method);
        final maxAttempts = retryAnnotation.peek('maxAttempts')?.intValue ?? 3;

        buffer.writeln('  /// Retry wrapper for $methodName');
        buffer.writeln('  $returnType ${methodName}WithRetry($params) async {');
        buffer.writeln('    int attempts = 0;');
        buffer.writeln('    while (attempts < $maxAttempts) {');
        buffer.writeln('      try {');
        buffer.writeln('        return await this.$methodName($paramNames);');
        buffer.writeln('      } catch (e) {');
        buffer.writeln('        attempts++;');
        buffer.writeln('        if (attempts >= $maxAttempts) rethrow;');
        buffer.writeln('        await Future.delayed(Duration(seconds: 1));');
        buffer.writeln('      }');
        buffer.writeln('    }');
        buffer.writeln('    throw Exception(\'Max retry attempts reached\');');
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateMutexMethods(ClassElement element) {
    final buffer = StringBuffer();
    final mutexChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Mutex',
    );

    for (final method in element.methods) {
      if (method.isStatic) continue;

      final mutexAnnotation = _getAnnotation(method, mutexChecker);
      if (mutexAnnotation != null) {
        final methodName = method.name;
        final returnType = method.returnType.getDisplayString();
        final params = _generateMethodParams(method);
        final paramNames = _generateParamNames(method);
        final lockKey =
            mutexAnnotation.peek('lockKey')?.stringValue ?? methodName;

        buffer.writeln('  /// Mutex-protected wrapper for $methodName');
        buffer.writeln('  $returnType ${methodName}Locked($params) async {');
        buffer.writeln('    await acquireLock(\'$lockKey\');');
        buffer.writeln('    try {');
        buffer.writeln('      return await this.$methodName($paramNames);');
        buffer.writeln('    } finally {');
        buffer.writeln('      releaseLock(\'$lockKey\');');
        buffer.writeln('    }');
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateTimeoutMethods(ClassElement element) {
    final buffer = StringBuffer();
    final timeoutChecker = TypeChecker.fromUrl(
      'package:stategen/src/annotations/concurrent_annotation.dart#Timeout',
    );

    for (final method in element.methods) {
      if (method.isStatic) continue;

      final timeoutAnnotation = _getAnnotation(method, timeoutChecker);
      if (timeoutAnnotation != null) {
        final methodName = method.name;
        final returnType = method.returnType.getDisplayString();
        final params = _generateMethodParams(method);
        final paramNames = _generateParamNames(method);

        buffer.writeln('  /// Timeout wrapper for $methodName');
        buffer.writeln(
          '  $returnType ${methodName}WithTimeout($params) async {',
        );
        buffer.writeln(
          '    return await this.$methodName($paramNames).timeout(',
        );
        buffer.writeln('      Duration(seconds: 30),');
        buffer.writeln(
          '      onTimeout: () => throw TimeoutException(\'$methodName timed out\'),',
        );
        buffer.writeln('    );');
        buffer.writeln('  }');
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  String _generateConcurrentAnnotationParams(ConstantReader annotation) {
    final params = <String>[];

    final maxConcurrent = annotation.peek('maxConcurrent')?.intValue;
    if (maxConcurrent != null && maxConcurrent != 1) {
      params.add('maxConcurrent: $maxConcurrent');
    }

    final queueKey = annotation.peek('queueKey')?.stringValue;
    if (queueKey != null) {
      params.add('queueKey: \'$queueKey\'');
    }

    final priority = annotation.peek('priority')?.intValue;
    if (priority != null && priority != 0) {
      params.add('priority: $priority');
    }

    final debounce = annotation.peek('debounce')?.boolValue;
    if (debounce == true) {
      params.add('debounce: true');
      final debounceDuration = annotation.peek('debounceDuration')?.revive();
      if (debounceDuration != null) {
        params.add('debounceDuration: Duration(milliseconds: 300)');
      }
    }

    final throttle = annotation.peek('throttle')?.boolValue;
    if (throttle == true) {
      params.add('throttle: true');
      final throttleDuration = annotation.peek('throttleDuration')?.revive();
      if (throttleDuration != null) {
        params.add('throttleDuration: Duration(milliseconds: 300)');
      }
    }

    return params.isEmpty ? '' : params.join(',\n    ');
  }

  String _generateValidators(ConstantReader annotation) {
    final buffer = StringBuffer();
    final validators = annotation.peek('validators')?.listValue ?? [];

    for (final validator in validators) {
      final validatorName = validator.toString();
      buffer.writeln('    // Validator: $validatorName');
      buffer.writeln('    if (!_validate$validatorName(value)) {');
      buffer.writeln(
        '      throw ValidationException(\'Validation failed for $validatorName\');',
      );
      buffer.writeln('    }');
    }

    return buffer.toString();
  }

  String _generateMethodParams(MethodElement method) {
    final params = <String>[];

    for (final param in method.formalParameters) {
      final type = param.type.getDisplayString();
      final name = param.name;

      if (param.isOptionalPositional) {
        params.add('[$type $name]');
      } else if (param.isNamed) {
        if (param.isRequired) {
          params.add('required $type $name');
        } else {
          final defaultValue = param.defaultValueCode;
          if (defaultValue != null) {
            params.add('$type $name = $defaultValue');
          } else {
            params.add('$type $name');
          }
        }
      } else {
        params.add('$type $name');
      }
    }

    return params.join(', ');
  }

  String _generateParamNames(MethodElement method) {
    final names = <String>[];

    for (final param in method.formalParameters) {
      if (param.isNamed) {
        names.add('${param.name}: ${param.name}');
      } else {
        names.add(param.name ?? '');
      }
    }

    return names.join(', ');
  }

  ConstantReader? _getAnnotation(Element element, TypeChecker checker) {
    final annotation = checker.firstAnnotationOf(element);
    return annotation == null ? null : ConstantReader(annotation);
  }

  String _capitalize(String str) {
    if (str.isEmpty) return str;
    return str[0].toUpperCase() + str.substring(1);
  }
}
